{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Token Storage",
  "steps": [
    {
      "file": "Source/Controllers/GitHubController.cs",
      "description": "# Starting the login process\r\nTo start, lets look at what happens when the database doesn't have the access or (valid) refresh tokens for the user and how the `state` parameter is generated. ",
      "line": 51,
      "selection": {
        "start": {
          "line": 51,
          "character": 17
        },
        "end": {
          "line": 51,
          "character": 56
        }
      }
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "## Creating the Redirect Uri\r\nTo get the `state` we have the `OAuthStateService` abstraction which is responsible for generating tamper-evident container for the `tenantId` and `userId`.\r\n\r\nThis is then used to craft a redirection to the `oauth/start` action on the `OAuthController` which redirects the user-agent to the `/authorize` endpoint for GitHub.",
      "line": 120
    },
    {
      "file": "Source/Services/OAuth/OAuthStateService/OAuthStateService.cs",
      "description": "## Generating the tamper-evident state\r\nWe use the [ASP.NET Core Data Protection APIs](https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/introduction?view=aspnetcore-6.0) to encrypt the user's id, tenant id and an `Id` which we will use later to detect replays of the same token. \r\n\r\nWe set the state to only be valid for a window of ~5 minutes by default to limit the amount of time we need to check for replay(s).\r\n\r\nThe data protection library creates both tamper evident and confidential payloads but in practice only the tamper evident property is required. You could use self-signed a [Json Web Token](https://datatracker.ietf.org/doc/html/rfc7519) or similar as your environment provides, we just use the data protection library for brevity. ",
      "line": 56,
      "selection": {
        "start": {
          "line": 47,
          "character": 1
        },
        "end": {
          "line": 56,
          "character": 99
        }
      }
    },
    {
      "file": "Source/Controllers/OAuthController.cs",
      "description": "## Finishing the OAuth flow & claiming tokens\r\n\r\nAfter directing the user-agent to the oauth/start action & the user completing the authorization flow the user-agent will be redirected back to this action `oauth/end` with a `code` parameter we can exchange for an access & refresh token.\r\n\r\nWe use the `OAuthTokenProvider` abstraction to acquire and persist the access tokens. This tour dives into the implementation of this abstraction. \r\n",
      "line": 66
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "The first thing to do when 'claiming' the code is to verify that this is a valid request. To do that we need to check that the `state` parameter is valid. ",
      "line": 98,
      "selection": {
        "start": {
          "line": 98,
          "character": 9
        },
        "end": {
          "line": 98,
          "character": 78
        }
      }
    },
    {
      "file": "Source/Services/OAuth/OAuthStateService/OAuthStateService.cs",
      "description": "We first `Unprotect` the state object using the Data protection API. This will ensure that the payload hasn't been tampered with and ensure that the `state` is being claimed within the specified window. \r\n\r\nE.G. the user isn't trying to complete the login an hour after starting the process. We time limit this both for security and to limit the number of ids needed for the next step.",
      "line": 64
    },
    {
      "file": "Source/Services/OAuth/OAuthStateService/OAuthStateService.cs",
      "description": "We also need to ensure that this `state` hasn't been claimed before. \r\n\r\nTo do this we use a repository of the ids we've seen. The repository only needs to hold onto the ids for as long as the token is valid which helps keep the total count of ids down. If a `state` is attempted to be claimed outside of the window it will fail the prior step so there isn't a concern for replay.\r\n\r\nThere are two implementations of this in this project, one naive in-memory implementation and another more robust impelementation that uses [Azure Table Storage](https://docs.microsoft.com/en-us/azure/storage/tables/table-storage-overview). In practice you only need a persistance layer that can handle check-and-set in a time-bounded manner.",
      "line": 73
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "After we've verified the `state` and extracted the `userId` and `tenantId` we now finish the [OAuth2.0 code flow](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1) (step 'D').\r\n\r\nThis code is a wrapper around the HTTP POST request to the `https://github.com/login/oauth/access_token` that pulls the remaining parts of the request from the configuration.",
      "line": 99
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "We then persist the refresh and access tokens into the database. ",
      "line": 110,
      "selection": {
        "start": {
          "line": 101,
          "character": 9
        },
        "end": {
          "line": 110,
          "character": 96
        }
      }
    },
    {
      "file": "Source/Services/UserTokenStore/InMemory/InMemoryUserTokenStore.cs",
      "description": "This is the most basic implementation of the user mapping. In it, we store the combination of the user's tenantId & userId as the key and their token(s) as values. \r\n\r\nIn practice this will almost always be done with some form of key-value database or persistance layer. There is an implementation of this in the `Services/UserTokenStore/TableStorage` directory if you want to see another example. ",
      "line": 7
    },
    {
      "file": "Source/Services/UserTokenStore/EncryptingUserTokenStoreDecorator.cs",
      "description": "## Securing the token persistence\r\n\r\nIn pracice we don't want to store the tokens in plain text. If the database or mapping is leaked, the attacker could now impersonate our application calling the downstream service. \r\n\r\nTo mitigate this we need to encrypt these tokens at rest and preferably in memory as well. This file is an implementation that handles encrypting and decrypting the tokens before persisting them.",
      "line": 6
    },
    {
      "file": "Source/Services/UserTokenStore/EncryptingUserTokenStoreDecorator.cs",
      "description": "# Salted protection\r\nThis code protects each token with a symmetric key that is salted with the tenant and user ids. This ensures that if an attacker manages to crack _one_ of the payloads they cannot gain access to all of them. \r\n\r\n",
      "line": 60,
      "selection": {
        "start": {
          "line": 58,
          "character": 1
        },
        "end": {
          "line": 60,
          "character": 64
        }
      }
    },
    {
      "file": "Source/Services/UserTokenStore/EncryptingUserTokenStoreDecorator.cs",
      "description": "This encryption is put together as a decorator around another token storage so that the persistance implementations can focus on the storage and retrieval and re-use this encryption layer. \r\n\r\nIn your own implementations this can be bundled with the persistance layer. ",
      "line": 62,
      "selection": {
        "start": {
          "line": 62,
          "character": 9
        },
        "end": {
          "line": 62,
          "character": 99
        }
      }
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "# Retriving the Access Token\r\n\r\nTo retrive the stored access token we need to first retrieve the access and refresh tokens",
      "line": 37
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "If the access token that was persisted is still valid, we should re-use it and not use the refresh token",
      "line": 57
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "We attempt to refresh the access token using the refresh token as specified [in the rfc](https://datatracker.ietf.org/doc/html/rfc6749#section-1.5) (step G/H)",
      "line": 66
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "If the refresh _fails_ we need to get the user to re-consent to the application. This is the same as if they haven't consented the first time so we generate a new `state` object and run the consent flow again.",
      "line": 70,
      "selection": {
        "start": {
          "line": 67,
          "character": 9
        },
        "end": {
          "line": 70,
          "character": 10
        }
      }
    },
    {
      "file": "Source/Services/OAuth/OAuthTokenProvider.cs",
      "description": "Before returning, we first persist the new token(s) ",
      "line": 88,
      "selection": {
        "start": {
          "line": 72,
          "character": 9
        },
        "end": {
          "line": 88,
          "character": 35
        }
      }
    }
  ],
  "ref": "nibeauli/account-linking-sample"
}